#!/usr/bin/env node

const { join } = require('node:path')
const { readFileSync, writeFileSync, unlinkSync } = require('node:fs')

const root = join(__dirname, '..', 'data', 'db', 'vm')

function fatal (msg) {
  console.error(msg)
  process.exit(1)
}

function getPayload (uuid) {
  try {
    const file = uuid ? join(root, `${uuid}.json`) : '/dev/stdin'
    return JSON.parse(readFileSync(file, 'utf-8'))
  } catch (e) {
    fatal(e)
  }
}

function setPayload (vm) {
  writeFileSync(join(root, `${vm.uuid}.json`), JSON.stringify(vm))
}

function getImageSize (uuid) {
  const imgRoot = join(__dirname, '..', 'data', 'db', 'img')
  try {
    const img = JSON.parse(readFileSync(join(imgRoot, `${uuid}.json`), 'utf-8'))
    return img.manifest.image_size
  } catch (e) {
    fatal(e)
  }
}

const cmd = {
  create: () => {
    const vm = getPayload()
    vm.ram = vm.ram || vm.max_physical_memory || 256
    vm.state = 'running'
    vm.quota = (vm.quota === null || vm.quota === undefined) ? 0 : vm.quota
    vm.cpu_shares = vm.cpu_shares || 100
    if (!vm.brand) {
      fatal('{"bad_brand": "undefined"}')
    }
    switch (vm.brand) {
      case 'joyent':
      case 'joyent-minimal':
        vm.max_physical_memory = vm.ram
        break
      case 'lx':
        vm.max_physical_memory = vm.ram
        vm.kernel_version = vm.kernel_version || '0.0.0'
        break
      case 'bhyve':
      case 'kvm':
        vm.vcpus = vm.vcpus || 1
        vm.max_physical_memory = vm.max_physical_memory || vm.ram + 1024
        vm.disks.forEach(d => {
          d.image_size = getImageSize(d.image_uuid)
        })
        break
    }
    const fileName = join(root, `${vm.uuid}.json`)
    setTimeout(() => writeFileSync(fileName, JSON.stringify(vm)), 2000)
  },
  validate: ([subcmd]) => {
    const { brand } = getPayload()
    if (!brand) {
      fatal('{"bad_brand": "undefined"}')
    }
    if (subcmd === 'create') {
      return console.error(`VALID 'create' payload for ${brand} brand VMs.`)
    }
    fatal(`${subcmd} is currently unsupported in the mock scripts`)
  },
  delete: ([uuid]) => unlinkSync(join(root, `${uuid}.json`)),
  start: ([uuid]) => {
    const vm = getPayload(uuid)
    if (vm.state === 'running') {
      return console.error(`Unable to start VM ${uuid}: VM ${uuid} is already 'running'`)
    } else {
      vm.state = 'running'
    }
    setPayload(vm)
    console.error(`Successfully started VM ${uuid}`)
  },
  stop: ([uuid]) => {
    const vm = getPayload(uuid)
    if (vm.state === 'stopped') {
      return console.error(`VM ${uuid} is already not 'running' (currently: stopped)`)
    } else {
      vm.state = 'stopped'
    }
    setPayload(vm)
    console.error(`Successfully completed stop for VM ${uuid}`)
  }
}

cmd[process.argv[2]](process.argv.slice(3))
