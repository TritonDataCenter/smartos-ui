#!/usr/bin/env node

const { join } = require('node:path')
const { readFileSync, writeFileSync, unlinkSync } = require('node:fs')

const root = join(__dirname, '..', 'data', 'db', 'vm')

function getPayload () {
  try {
    return JSON.parse(readFileSync('/dev/stdin', 'utf-8'))
  } catch (e) {
    console.error(e)
    process.exit(1)
  }
}

function getImageSize (uuid) {
  const imgRoot = join(__dirname, '..', 'data', 'db', 'img')
  try {
    const img = JSON.parse(readFileSync(join(imgRoot, `${uuid}.json`), 'utf-8'))
    return img.manifest.image_size
  } catch (e) {
    console.error(e)
    process.exit(1)
  }
}

const cmd = {
  create: () => {
    const vm = getPayload()
    vm.ram = vm.ram || vm.max_physical_memory || 256
    vm.state = 'running'
    vm.quota = (vm.quota === null || vm.quota === undefined) ? 0 : vm.quota
    switch (vm.brand) {
      case 'joyent':
      case 'joyent-minimal':
        vm.max_physical_memory = vm.ram
        break
      case 'lx':
        vm.max_physical_memory = vm.ram
        vm.kernel_version = vm.kernel_version || '0.0.0'
        break
      case 'bhyve':
      case 'kvm':
        vm.max_physical_memory = vm.max_physical_memory || vm.ram + 1024
        vm.disks.forEach(d => {
          d.image_size = getImageSize(d.image_uuid)
        })
        break
    }
    const fileName = join(root, `${vm.uuid}.json`)
    setTimeout(() => writeFileSync(fileName, JSON.stringify(vm)), 2000)
  },
  validate: ([subcmd]) => {
    const { brand } = getPayload()
    if (!brand) {
      console.error('{"bad_brand": "undefined"}')
      process.exit(1)
    }
    if (subcmd === 'create') {
      // vmadm writes success message to stderr
      return console.error(`VALID 'create' payload for ${brand} brand VMs.`)
    }
    console.error(`${subcmd} is currently unsupported in the mock scripts`)
    process.exit(1)
  },
  delete: ([uuid]) => unlinkSync(join(root, `${uuid}.json`))
}

cmd[process.argv[2]](process.argv.slice(3))
